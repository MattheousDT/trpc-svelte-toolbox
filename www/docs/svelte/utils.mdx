---
id: utils
title: utils
sidebar_label: utils
slug: /svelte/utils
---

`utils` is a hook that gives you access to helpers that 
let you manage the cached data of the queries you execute via `@trpc/svelte-query`.
These helpers are actually thin wrappers around 
`@tanstack/svelte-query`'s [`queryClient`](https://tanstack.com/query/v4/docs/reference/QueryClient) methods. 
If you want more in-depth information about options and usage patterns 
for `utils` helpers than what we provide here,
we will link to their respective `@tanstack/svelte-query` docs so you can refer to them accordingly.

## Usage

`utils` returns a proxy with all the available queries you have in your routers.
You use it the same way as your `trpc` client object.
Once you reach a query, you'll have access to the query helpers.
For example, let's say you have a `post` router with an `all` query:

```tsx title='src/lib/server/trpc.ts'
import { z } from 'zod';
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    all: t.procedure.query(() => {
      return {
        posts: [
          { id: 1, title: 'everlong' },
          { id: 2, title: 'After Dark' },
        ],
      };
    }),
  }),
});

export type AppRouter = typeof appRouter;
```

Now in our component, 
when we navigate the object `useContext` gives us and reach the `post.all` query,
we'll get access to our query helpers!

```html title="MyComponent.tsx"
<script lang="ts">
  import { trpc } from '$lib/trpc'
  
  const utils = trpc.utils
  utils.post.all.f;
  //              ^|
  // [...]

  // (TypeScript info is supposed to popup from twoslash, but idk how to use it with Svelte)
</script>

```

## Helpers

These are the helpers you'll get access to via `utils`.
The table below will help you know which tRPC helper wraps which `@tanstack/svelte-query` helper method.
Each svelte-query method will link to its respective docs/guide:

:::note
There's literally no documentation on svelte-query lol,
so these just point to the react ones like the original docs.
:::

| tRPC helper wrapper | `@tanstack/react-query` helper method                                                                                            |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `fetch`             | [`queryClient.fetchQuery`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientfetchquery)                       |
| `prefetch`          | [`queryClient.prefetchQuery`](https://tanstack.com/query/v4/docs/guides/prefetching)                                             |
| `fetchInfinite`     | [`queryClient.fetchInfiniteQuery`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientfetchinfinitequery)       |
| `prefetchInfinite`  | [`queryClient.prefetchInfiniteQuery`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientprefetchinfinitequery) |
| `ensureData`        | [`queryClient.ensureData`](https://tanstack.com/query/v4/docs/react/reference/QueryClient#queryclientensurequerydata)            |
| `invalidate`        | [`queryClient.invalidateQueries`](https://tanstack.com/query/v4/docs/guides/query-invalidation)                                  |
| `refetch`           | [`queryClient.refetchQueries`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientrefetchqueries)               |
| `cancel`            | [`queryClient.cancelQuery`](https://tanstack.com/query/v4/docs/guides/query-cancellation)                                        |
| `setData`           | [`queryClient.setQueryData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientsetquerydata)                   |
| `getData`           | [`queryClient.getQueryData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientgetquerydata)                   |
| `setInfiniteData`   | [`queryClient.setInfiniteQueryData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientsetquerydata)           |
| `getInfiniteData`   | [`queryClient.getInfiniteData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientgetquerydata)                |

## Proxy client

In addition to the above svelte-query helpers,
the context also exposes your tRPC proxy client.
This lets you call your procedures with `async`/`await` without needing to create an additional vanilla client.

```html
<script lang="ts">
  import { trpc } from '../utils/trpc';

  const utils = trpc.utils

  let apiKey

  type FormSubmitEvent = Event & 
    { readonly submitter: HTMLElement | null } & 
    { currentTarget: EventTarget & HTMLFormElement }

  const handleSubmit = async (event: FormSubmitEvent) => {
    const apiKey = await utils.client.apiKey.create.mutate(event);
    setApiKey(apiKey);
  }
</script>

<form on:submit={handleSubmit}>
  ...
</form>

```

## Query Invalidation

You invalidate queries via the `invalidate` helper. 
`invalidate` is actually a special helper given that, unlike the other helpers,
it's available at every level of the router map.

This means you can either run `invalidate` on a single query, a whole router, or every router if you want.
We get more in detail in the sections below.


### Invalidating a single query

You can invalidate a query relating to a single procedure and even filter based
on the input passed to it to prevent unnecessary calls to the back end.

#### Example code

```html
<script lang="ts">
  import { trpc } from '$lib/trpc';
  const utils = trpc.utils;

  const mutation = trpc.post.edit.useMutation({
    onSuccess(input) {
      utils.post.all.invalidate();
      utils.post.byId.invalidate({ id: input.id }); // Will not invalidate queries for other id's üëç
    },
  });
</script>

```

### Invalidating across whole routers

It is also possible to invalidate queries across an entire router rather then
just one query.

#### Example code

<details><summary>Backend code</summary>

```tsx title='server/routers/_app.ts'
import { z } from 'zod';
import { initTRPC } from '@trpc/server';

export const t = initTRPC.create();

export const appRouter = t.router({
  // sub Post router
  post: t.router({
    all: t.procedure.query(() => {
      return {
        posts: [
          { id: 1, title: 'everlong' },
          { id: 2, title: 'After Dark' },
        ],
      };
    }),
    byId: t.procedure
      .input(
        z.object({
          id: z.string(),
        }),
      )
      .query(({ input }) => {
        return {
          post: { id: input?.id, title: 'Look me up!' },
        };
      }),
    edit: t.procedure
      .input(z.object({ id: z.number(), title: z.string() }))
      .mutation(({ input }) => {
        return { post: { id: input.id, title: input.title } };
      }),
  }),
  // separate user router
  user: t.router({
    all: t.procedure.query(() => {
      return { users: [{ name: 'Dave Grohl' }, { name: 'Haruki Murakami' }] };
    }),
  }),
});
```

</details>

```html
<script lang="ts">
  import { trpc } from '$lib/trpc';
  const utils = trpc.utils

  const invalidateAllQueriesAcrossAllRouters = () => {
    // 1Ô∏è‚É£
    // All queries on all routers will be invalidated üî•
    utils.invalidate();
  };

  const invalidateAllPostQueries = () => {
    // 2Ô∏è‚É£
    // All post queries will be invalidated üì≠
    utils.post.invalidate();
  };

  const invalidatePostById = () => {
    // 3Ô∏è‚É£
    // All queries in the post router with input {id:1} invalidated üì≠
    utils.post.byId.invalidate({ id: 1 });
  };

  // Example queries
  trpc.user.all.createQuery(); // Would only be validated by 1Ô∏è‚É£ only.
  trpc.post.all.createQuery(); // Would be invalidated by 1Ô∏è‚É£ & 2Ô∏è‚É£
  trpc.post.byId.createQuery({ id: 1 }); // Would be invalidated by 1Ô∏è‚É£, 2Ô∏è‚É£ and 3Ô∏è‚É£
  trpc.post.byId.createQuery({ id: 2 }); // would be invalidated by 1Ô∏è‚É£ and 2Ô∏è‚É£ but NOT 3Ô∏è‚É£!
</script>

{ ... }

```

### Invalidate full cache on every mutation -- NOT IMPLEMENTED

Keeping track of exactly what queries a mutation should invalidate is hard, therefore,
it can be a pragmatic solution to invalidate the _full cache_ as a side-effect on any mutation.
Since we have request batching, this invalidation will simply refetch all queries on the page you're looking at in one single request.

We have added a feature to help with this:

```ts
export const trpc = createTRPCReact<AppRouter, SSRContext>({
  unstable_overrides: {
    useMutation: {
      /**
       * This function is called whenever a `.useMutation` succeeds
       **/
      async onSuccess(opts) {
        /**
         * @note that order here matters:
         * The order here allows route changes in `onSuccess` without
         * having a flash of content change whilst redirecting.
         **/

        // Calls the `onSuccess` defined in the `useQuery()`-options:
        await opts.originalFn();

        // Invalidate all queries in the react-query cache:
        await opts.queryClient.invalidateQueries();
      },
    },
  },
});
```

## Additional Options -- NOT IMPLEMENTED

Aside from the query helpers, the proxy `utils` returns also contains the following properties:

```ts
interface ProxyTRPCContextProps<TRouter extends AnyRouter, TSSRContext> {
  /**
   * The `TRPCClient`
   */
  client: TRPCProxyClient<TRouter>;

  /**
   * The SSR context when server-side rendering
   * @default null
   */
  ssrContext?: TSSRContext | null;

  /**
   * State of SSR hydration.
   * - `false` if not using SSR.
   * - `prepass` when doing a prepass to fetch queries' data
   * - `mounting` before TRPCProvider has been rendered on the client
   * - `mounted` when the TRPCProvider has been rendered on the client
   * @default false
   */
  ssrState?: SSRState;

  /**
   * Abort loading query calls when unmounting a component - usually when navigating to a new page
   * @default false
   */
  abortOnUnmount?: boolean;
}
```
