---
id: setup
title: Set up the Svelte Query Integration
sidebar_label: Setup
description: How to use and setup tRPC in Svelte
slug: /svelte/setup
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

### 1. Install dependencies

The following dependencies should be installed

<Tabs>
  <TabItem value="npm" label="npm" default>

```bash
npm install @trpc/client @trpc/server @tanstack/svelte-query @bevm0/trpc-svelte-query 
```

  </TabItem>

  <TabItem value="yarn" label="yarn">

```bash
yarn add @trpc/client @trpc/server @tanstack/svelte-query @bevm0/trpc-svelte-query 
```

  </TabItem>

  <TabItem value="pnpm" label="pnpm">

```bash
pnpm add @trpc/client @trpc/server @tanstack/svelte-query @bevm0/trpc-svelte-query 
```

  </TabItem>
</Tabs>

### 2. Create your `AppRouter`

```ts title='src/lib/server/trpc.ts'
import { z } from "zod";
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

const appRouter = t.router({
  getUser: t.procedure.input(z.object({ id: z.string() })).query(() => ({ name: 'Pardo' })),
  createUser: t.procedure.input(z.object({ name: z.string() })).mutation(() => 'Felis'),
});

export type AppRouter = typeof appRouter;
```

### 3. Create tRPC hooks

Create a set of strongly-type Svelte hooks from your `AppRouter` type signature with `createTRPCSvelte`.

:::tip
These are meant to be used **in components only**.
[See how to use `loadContext` in SvelteKit load functions here](/sveltekit/setup).

In SvelteKit, it's possible for this client to be initialized on either the server or the client.
As a result, this client is "disconnected" from any explicit query client to prevent "cache pollution".
It will only save its data to the query client specified by `setContext` within components.

In load functions, we want to explicitly write to the query client since there
is no context outside of components, and we create a new one per +layout.ts;
the `loadContext` will invoke the typical contextual functions directly on the query client.

Once the page loads, the hydrated query client is provided to the `QueryClientProvider`
and also set in the trpc context so that everything on the component level is synchronized.
:::

```ts title='src/lib/trpc.ts'
import { createTRPCSvelte } from '@bevm0/trpc-svelte-query';
import { httpBatchLink } from '@trpc/client';
import type { AppRouter } from '$lib/server/trpc';

export const trpc = createTRPCSvelte<AppRouter>({
  links: [ 
    httpBatchLink({ url: 'http://localhost:5173/api/trpc' })
  ]
});
```

### 4. Add Svelte-Query providers

Set up and connect Svelte Query,
which [is documented in more depth here](https://tanstack.com/query/latest/docs/svelte/overview#example).

:::tip
If you already use Svelte Query in your application, you **should** re-use the `QueryClient` and `QueryClientProvider` you already have.
:::

```html title='src/routes/+layout.svelte'
<script lang="ts">
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query';
  import { trpc } from '$lib/trpc'

  const queryClient = new QueryClient()

  trpc.setContext(queryClient)
</script>

<QueryClientProvider client={queryClient}>
  <slot />
</QueryClientProvider>
```
:::note
The extra 'setContext' step is used to synchronize multiple tRPC clients with the same query client.
i.e. you can initialize multiple trpc clients via `createTRPCSvelte`
and contextual functions from `getContext` will apply to the same queryClient.

It also allows a single `context` proxy to be created once during the layout load, 
and not have to be recalculated everytime `getContext` is called.

It's intended to be analogous to the `trpc.Provider` component in react-query.
:::

### 5. Fetch data

You can now use the tRPC Svelte Query integration to 
call queries and mutations on your API.

:::note
`useQuery`, `useMutation`, etc. from @trpc/react-query and @tanstack/react-query
are renamed to `createQuery`, `createMutation`, etc.
based on the naming conventions in @trpc/svelte-query
:::

```html title='src/routes/+page.svelte'
<script lang="ts">
  import { trpc } from '$lib/trpc'

  const userQuery = trpc.getUser.createQuery({ id: 'Eden' });
  const userCreator = trpc.createUser.createMutation();

  function handleClick() {
    $userCreator.mutate({ name: 'Elysia' })
  }
</script>

<div>
  <p>{$userQuery.data?.name}</p>
  <button on:click={handleClick}>Create Elysia</button>
</div>
```
